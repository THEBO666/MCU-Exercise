C51 COMPILER V8.06   1602_CHUANKOU                                                         06/24/2012 20:13:35 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE 1602_CHUANKOU
OBJECT MODULE PLACED IN 1602-chuankou.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 1602-chuankou.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************HJ-3G实验开发板例程************************
   2          *  平台：HJ-3G V6.0 + Keil U3 + STC89C52
   3          *  名称：
   4          *  公司：慧净电子科技有限公司
   5          *  淘宝：http://shop37031453.taobao.com       
   6          *  网站：www.hlmcu.com
   7          *  编写：
   8          *  日期：2008-8-08
   9          *   QQ : 121350852  398115088
  10          *  晶振:11.0592MHZ
  11          *  说明：免费开源，不提供源代码分析，有问题直接到慧净论坛交流
  12          *  论坛：http://hjdz.5d6d.com
  13          /******************************************************************/
  14          
  15          //注意事项：10天教程中的LCD1602第5脚由于当时设计错误，直接接到GND上了，接了低电平。
  16          //本实验需要把LCD1602第5脚，读/写脚接到GND上，有两种方法，第一种，用杜邦线把P3.6脚接到GND上。
  17          //另一种方法，定义一个 P3.6 IO口，在主函数中 把P3.6 写一个低电平就可以了。 
  18          /*****************************************************************
  19          *************************************************************************
  20          * 描述：（用串口调试助手软件观察）                                                              *
  21          *   主机发送123456给单片机，单片机接收到数据后发送HJ-3G给主机。         *
  22          *   主机发送其它数据给单片机，单片机接收到数据后，再发送给主机。        *
  23          *   LCD1602显示接收数据的ASCII码。  波特率9600                          *
  24          *   注：当单片机收到数据只有凑够16个时才会一次在液晶上显示出来          *
  25          ************************************************************************/
  26          
  27          #include <reg52.h>
  28          #include <intrins.h>
  29                  
  30          #define uchar  unsigned char 
  31          #define uint   unsigned int
  32          
  33          sbit LCD_RS = P1^0;
  34          sbit LCE_RW = P1^1;             
  35          sbit LCD_EN = P2^5;
  36          
  37          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  38          
  39          
  40          uchar data  RXDdata[ ] = {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  41                                    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 };
  42          uchar temp,buf,m,count;
  43          
  44          bit   playflag=0;
  45          
  46          uchar code  cdis1[ ] = {" SERILA TRANFER "};
  47          uchar code  cdis2[ ] = {"                "};
  48          
  49          /**********************************************************
  50          
  51           延时子程序
  52          
  53          **********************************************************/
  54          void delay1(uint ms) 
  55          
C51 COMPILER V8.06   1602_CHUANKOU                                                         06/24/2012 20:13:35 PAGE 2   

  56          {
  57   1         uchar k;
  58   1         while(ms--)
  59   1         {
  60   2           for(k = 0; k < 120; k++);
  61   2         }
  62   1      }
  63          
  64          /******************************************************************/
  65          /*                                                                */
  66          /*检查LCD忙状态                                                   */
  67          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。     */
  68          /*                                                                */
  69          /******************************************************************/ 
  70          bit lcd_busy()
  71           {                          
  72   1          bit result;
  73   1          LCD_RS = 0;
  74   1      //    LCD_RW = 1;
  75   1          LCD_EN = 1;
  76   1          delayNOP();
  77   1          result = (bit)(P0&0x80);
  78   1          LCD_EN = 0;
  79   1          return(result); 
  80   1       }
  81          
  82          /*******************************************************************/
  83          /*                                                                 */
  84          /*写指令数据到LCD                                                  */
  85          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  86          /*                                                                 */
  87          /*******************************************************************/
  88          void lcd_wcmd(uchar cmd)
  89          {                          
  90   1       //  while(lcd_busy());
  91   1          LCD_RS = 0;
  92   1        //  LCD_RW = 0;
  93   1          LCD_EN = 0;
  94   1          _nop_();
  95   1          _nop_(); 
  96   1          P0 = cmd;
  97   1          delayNOP();
  98   1          LCD_EN = 1;
  99   1          delayNOP();
 100   1          LCD_EN = 0;  
 101   1      }
 102          
 103          /*******************************************************************/
 104          /*                                                                 */
 105          /*写显示数据到LCD                                                  */
 106          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 107          /*                                                                 */
 108          /*******************************************************************/
 109          void lcd_wdat(uchar dat)
 110          {                          
 111   1      //   while(lcd_busy());
 112   1          LCD_RS = 1;
 113   1        //  LCD_RW = 0;
 114   1          LCD_EN = 0;
 115   1          P0 = dat;
 116   1          delayNOP();
 117   1          LCD_EN = 1;
C51 COMPILER V8.06   1602_CHUANKOU                                                         06/24/2012 20:13:35 PAGE 3   

 118   1          delayNOP();
 119   1          LCD_EN = 0; 
 120   1      }
 121          
 122          /*******************************************************************/
 123          /*                                                                 */
 124          /*  LCD初始化设定                                                  */
 125          /*                                                                 */
 126          /*******************************************************************/
 127          void lcd_init()
 128          { 
 129   1           LCE_RW = 0; 
 130   1          delay1(15);   
 131   1          lcd_wcmd(0x01);      //清除LCD的显示内容            
 132   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 133   1          delay1(5);
 134   1          lcd_wcmd(0x38);         
 135   1          delay1(5);
 136   1          lcd_wcmd(0x38);         
 137   1          delay1(5);
 138   1      
 139   1          lcd_wcmd(0x0c);      //开显示，显示光标，光标闪烁
 140   1          delay1(5);
 141   1      
 142   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 143   1          delay1(5);
 144   1      }
 145          
 146          /*******************************************************************/
 147          /*                                                                 */
 148          /*  设定显示位置                                                   */
 149          /*                                                                 */
 150          /*******************************************************************/
 151          
 152          void lcd_pos(uchar pos)
 153          {                          
 154   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 155   1      }
 156          
 157          /*********************************************************
 158          
 159            发送数据函数
 160          
 161          *********************************************************/
 162          void senddata(uchar dat)
 163          {
 164   1           SBUF =dat;
 165   1           while(!TI);
 166   1           TI = 0;
 167   1      }
 168          
 169          /*********************************************************
 170          
 171            串行中断服务函数
 172          
 173          *********************************************************/
 174          void  serial() interrupt 4 
 175          {
 176   1         ES = 0;                //关闭串行中断
 177   1         RI = 0;                //清除串行接受标志位
 178   1         buf = SBUF;            //从串口缓冲区取得数据
 179   1           
C51 COMPILER V8.06   1602_CHUANKOU                                                         06/24/2012 20:13:35 PAGE 4   

 180   1         switch(buf)
 181   1         {
 182   2            case 0x31:  senddata('T');break;  //接受到1，发送字符'T'给计算机         
 183   2            case 0x32:  senddata('X');break;  //接受到2，发送字符'X'给计算机       
 184   2            case 0x33:  senddata('-');break;  //接受到3，发送字符'-'给计算机       
 185   2            case 0x34:  senddata('M');break;  //接受到4，发送字符'M'给计算机       
 186   2            case 0x35:  senddata('C');break;  //接受到5，发送字符'C'给计算机           
 187   2            case 0x36:  senddata('U');break;  //接受到5，发送字符'U'给计算机                  
 188   2            default:    senddata(buf);break;  //接受到其它数据，将其发送给计算机         
 189   2         }
 190   1      
 191   1         if(buf!=0x0D)
 192   1         {   
 193   2           if(buf!=0x0A)
 194   2           { 
 195   3             temp =buf;
 196   3             if(count<16)
 197   3             {         
 198   4               RXDdata[count]=temp;
 199   4               count++;
 200   4                       if(count==16)
 201   4                              playflag=1;
 202   4             }
 203   3           } 
 204   2         }
 205   1         ES = 1;    //允许串口中断
 206   1      }
 207          
 208          /*********************************************************
 209          
 210            数据显示函数
 211          
 212          *********************************************************/
 213          void  play()
 214          {
 215   1         if(playflag)
 216   1         { 
 217   2           lcd_pos(0x40);           //设置位置为第二行
 218   2           for(m=0;m<16;m++) 
 219   2           {
 220   3                      lcd_wdat(cdis2[m]);      //清LCD1602第二行
 221   3                      delay1(5);
 222   3               }
 223   2               lcd_pos(0x40);           //设置位置为第二行
 224   2           for(m=0;m<16;m++)
 225   2           {
 226   3          //   lcd_pos(0x40+m);       //设置显示位置为第二行
 227   3             lcd_wdat(RXDdata[m]);  //显示字符 
 228   3                 delay1(5);
 229   3           }
 230   2      
 231   2           playflag=0;              
 232   2           count=0x00;
 233   2      
 234   2           for(m=0;m<16;m++)      
 235   2           {
 236   3                      RXDdata[m]=0x20;         //清显存单元    
 237   3                      delay1(5);
 238   3               }
 239   2         }               
 240   1      }
 241          
C51 COMPILER V8.06   1602_CHUANKOU                                                         06/24/2012 20:13:35 PAGE 5   

 242          /*********************************************************
 243          
 244            主函数
 245          
 246          *********************************************************/
 247          void main(void) 
 248          {
 249   1          P0 = 0xff;
 250   1          P2 = 0xff;         
 251   1          
 252   1          SCON=0x50;           //设定串口工作方式
 253   1          PCON=0x00;           //波特率不倍增
 254   1                              
 255   1          TMOD=0x20;           //定时器1工作于8位自动重载模式, 用于产生波特率
 256   1          EA=1;
 257   1          ES = 1;              //允许串口中断
 258   1          TL1=0xfd;
 259   1          TH1=0xfd;             //波特率9600
 260   1          TR1=1;
 261   1      
 262   1          lcd_init();
 263   1          lcd_pos(0x00);        //设置显示位置为第一行
 264   1          for(m=0;m<16;m++) 
 265   1          {
 266   2                      lcd_wdat(cdis1[m]);   //显示字符
 267   2                      delay1(5);
 268   2              }
 269   1          lcd_pos(0x40);        //设置显示位置为第二行
 270   1          for(m=0;m<16;m++) 
 271   1          {
 272   2                      lcd_wdat(cdis2[m]);   //显示字符            
 273   2                      delay1(5);
 274   2              }
 275   1          while(1)        
 276   1          {
 277   2            play();       
 278   2          }
 279   1      }
 280          
 281          /*********************************************************/ 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    439    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
