C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE 0
OBJECT MODULE PLACED IN 0.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 0.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************HJ-3G实验开发板例程************************
   2          *  平台：HJ-3G V6.0 + Keil U3 + STC89C52
   3          *  名称：读取DS18B20的64位序列码并显示在1602液晶上
   4          *  公司：慧净电子科技有限公司
   5          *  淘宝：http://shop37031453.taobao.com       
   6          *  网站：www.hlmcu.com
   7          *  编写：
   8          *  日期：2008-8-08
   9          *   QQ : 121350852  398115088
  10          *  晶振:11.0592MHZ
  11          *  说明：免费开源，不提供源代码分析，有问题直接到慧净论坛交流
  12          *  论坛：http://hjdz.5d6d.com
  13          ******************************************************************/
  14          
  15          //注意事项：10天教程中的LCD1602第5脚由于当时设计错误，直接接到GND上了，接了低电平。
  16          //本实验需要把LCD1602第5脚，读/写脚接到GND上，有两种方法，第一种，用杜邦线把P3.6脚接到GND上。
  17          //另一种方法，定义一个 P3.6 IO口，在主函数中 把P3.6 写一个低电平就可以了。
  18          
  19          /*读取DS18B20的64位序列码并显示在1602液晶上，如果读取正确结果，则在
  20          液晶第一行显示DS18B20 OK，第二行显示序列码，如果读取失败，则在液晶上
  21          显示DS18B20  ERR0R PLEASE CHECK ，用户可通过更改18B20接口自己外接。 */
  22          #include <reg51.h>
  23          #include <intrins.h>
  24          
  25          #define uchar unsigned char
  26          #define uint  unsigned int
  27          
  28          sbit DQ = P2^2;  //定义DS18B20端口DQ  
  29          sbit BEEP=P2^3 ; //蜂鸣器驱动线
  30          
  31          bit  presence ;
  32          
  33          sbit LCD_RS = P1^0;             
  34          sbit LCD_RW = P1^1;
  35          sbit LCD_EN = P2^5;
  36          
  37          uchar code  cdis1[ ] = {"   DS18B20 OK   "};
  38          uchar code  cdis2[ ] = {"                "};
  39          uchar code  cdis3[ ] = {" DS18B20  ERR0R "};
  40          uchar code  cdis4[ ] = {"  PLEASE CHECK  "};
  41          
  42          unsigned char data  display[2] = {0x00,0x00};
  43                                              
  44          unsigned char data  RomCode[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  45          
  46          unsigned char Temp;
  47          unsigned char  crc;
  48          
  49          void beep();
  50          
  51          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  52          
  53          /*******************************************************************/
  54          void delay1(int ms)
  55          {
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 2   

  56   1       unsigned char y;
  57   1        while(ms--)
  58   1       {
  59   2        for(y = 0; y<250; y++)
  60   2        {
  61   3         _nop_();
  62   3         _nop_();
  63   3         _nop_();
  64   3         _nop_();
  65   3        }
  66   2       }
  67   1      }
  68          
  69          /******************************************************************/
  70          /*                                                                */
  71          /*检查LCD忙状态                                                   */
  72          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。     */
  73          /*                                                                */
  74          /******************************************************************/ 
  75          
  76          bit lcd_busy()
  77           {                          
  78   1          bit result;
  79   1          LCD_RS = 0;
  80   1      //    LCD_RW = 1;
  81   1          LCD_EN = 1;
  82   1          delayNOP();
  83   1          result = (bit)(P0&0x80);
  84   1          LCD_EN = 0;
  85   1          return(result); 
  86   1       }
  87          
  88          /*******************************************************************/
  89          /*                                                                 */
  90          /*写指令数据到LCD                                                  */
  91          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  92          /*                                                                 */
  93          /*******************************************************************/
  94          
  95          void lcd_wcmd(uchar cmd)
  96          
  97          {                          
  98   1       //  while(lcd_busy());
  99   1          LCD_RS = 0;
 100   1       //   LCD_RW = 0;
 101   1          LCD_EN = 0;
 102   1          _nop_();
 103   1          _nop_(); 
 104   1          P0 = cmd;
 105   1          delayNOP();
 106   1          LCD_EN = 1;
 107   1          delayNOP();
 108   1          LCD_EN = 0;  
 109   1              delay1(5);
 110   1      }
 111          
 112          /*******************************************************************/
 113          /*                                                                 */
 114          /*写显示数据到LCD                                                  */
 115          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 116          /*                                                                 */
 117          /*******************************************************************/
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 3   

 118          
 119          void lcd_wdat(uchar dat)
 120          {                          
 121   1      //   while(lcd_busy());
 122   1          LCD_RS = 1;
 123   1      //    LCD_RW = 0;
 124   1          LCD_EN = 0;
 125   1          P0 = dat;
 126   1          delayNOP();
 127   1          LCD_EN = 1;
 128   1          delayNOP();
 129   1          LCD_EN = 0; 
 130   1              delay1(5);
 131   1      }
 132          
 133          /*******************************************************************/
 134          /*                                                                 */
 135          /*  LCD初始化设定                                                  */
 136          /*                                                                 */
 137          /*******************************************************************/
 138          
 139          void lcd_init()
 140          { 
 141   1           LCD_RW = 0;
 142   1          delay1(15);   
 143   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 144   1                  
 145   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 146   1          delay1(5);
 147   1          lcd_wcmd(0x38);         
 148   1          delay1(5);
 149   1          lcd_wcmd(0x38);         
 150   1          delay1(5);
 151   1      
 152   1          lcd_wcmd(0x0c);      //显示开，关光标
 153   1          delay1(5);
 154   1          lcd_wcmd(0x06);      //移动光标
 155   1          delay1(5);
 156   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 157   1          delay1(5);
 158   1      }
 159          
 160          /*******************************************************************/
 161          /*                                                                 */
 162          /*  设定显示位置                                                   */
 163          /*                                                                 */
 164          /*******************************************************************/
 165          
 166          void lcd_pos(uchar pos)
 167          {                          
 168   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 169   1      }
 170          
 171          /*******************************************************************/
 172          /*                                                                 */
 173          /*us级延时函数                                                     */
 174          /*                                                                 */
 175          /*******************************************************************/
 176          
 177          void Delay(unsigned int num)
 178          {
 179   1        while( --num );
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 4   

 180   1      }
 181          
 182          /*******************************************************************/
 183          /*                                                                 */
 184          /*初始化ds1820                                                     */
 185          /*                                                                 */
 186          /*******************************************************************/
 187          Init_DS18B20(void)
 188          {  
 189   1           DQ = 1;      //DQ复位
 190   1           Delay(8);    //稍做延时
 191   1      
 192   1           DQ = 0;      //将DQ拉低
 193   1           Delay(90);   //精确延时 大于 480us
 194   1      
 195   1           DQ = 1;       //拉高总线
 196   1           Delay(8);
 197   1      
 198   1           presence = DQ;    //读取存在信号
 199   1           Delay(100);
 200   1           DQ = 1; 
 201   1           
 202   1           return(presence); //返回信号，0=presence,1= no presence
 203   1      }
 204          
 205          /*******************************************************************/
 206          /*                                                                 */
 207          /* 读一位（bit）                                                   */
 208          /*                                                                 */
 209          /*******************************************************************/
 210          uchar read_bit(void) 
 211          {
 212   1      unsigned char i;
 213   1      DQ = 0;                  //将DQ 拉低开始读时间隙
 214   1      DQ = 1;                         // then return high
 215   1      for (i=0; i<3; i++);    // 延时15μs
 216   1      return(DQ);                     // 返回 DQ 线上的电平值
 217   1      }
 218          
 219          /*******************************************************************/
 220          /*                                                                 */
 221          /* 读一个字节                                                      */
 222          /*                                                                 */
 223          /*******************************************************************/
 224           ReadOneChar(void)
 225          {
 226   1      unsigned char i = 0;
 227   1      unsigned char dat = 0;
 228   1      
 229   1      //for (i = 8; i > 0; i--)
 230   1      //  {
 231   1      //       read_bit();
 232   1      //    DQ = 0; // 给脉冲信号
 233   1      //     dat >>= 1;
 234   1      //    DQ = 1; // 给脉冲信号
 235   1      for (i=0;i<8;i++) 
 236   1      {                               // 读取字节，每次读取一个字节
 237   2      if(read_bit()) dat|=0x01<<i;    // 然后将其左移
 238   2      
 239   2      //    if(DQ)
 240   2      //     dat |= 0x80;
 241   2          Delay(4);
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 5   

 242   2        }
 243   1      
 244   1          return (dat);
 245   1      }
 246          
 247          /*******************************************************************/
 248          /*                                                                 */
 249          /* 写一位                                                          */
 250          /*                                                                 */
 251          /*******************************************************************/
 252          void write_bit(char bitval) {
 253   1      DQ = 0;                                        // 将DQ 拉低开始写时间隙
 254   1      if(bitval==1) DQ =1;     // 如果写1，DQ 返回高电平
 255   1      Delay(5);                                     // 在时间隙内保持电平值，
 256   1      DQ = 1;                  // Delay函数每次循环延时16μs，因此delay(5) = 104μs
 257   1      }       
 258          
 259          /*******************************************************************/
 260          /*                                                                 */
 261          /* 写一个字节                                                      */
 262          /*                                                                 */
 263          /*******************************************************************/
 264           WriteOneChar(unsigned char dat)
 265          {
 266   1        unsigned char i = 0;
 267   1        unsigned char temp;
 268   1      //  for (i = 8; i > 0; i--)
 269   1      //  {
 270   1         for (i=0; i<8; i++)  // 写入字节, 每次写入一位 
 271   1         {
 272   2      //    DQ = 0;
 273   2      //    DQ = dat&0x01;
 274   2      //    Delay(5);
 275   2      
 276   2      //    DQ = 1;
 277   2         temp = dat>>i;               
 278   2         temp &= 0x01;                
 279   2         write_bit(temp);
 280   2      //    dat>>=1;
 281   2         
 282   2        }
 283   1        Delay(5);
 284   1      }
 285          
 286          /*******************************************************************/
 287          /*                                                                 */
 288          /* 读取64位序列码                                                  */
 289          /*                                                                 */
 290          /*******************************************************************/
 291           Read_RomCord(void)
 292          {
 293   1           unsigned char j;
 294   1           Init_DS18B20();
 295   1        
 296   1           WriteOneChar(0x33);  // 读序列码的操作
 297   1           for (j = 0; j < 8; j++)
 298   1               {
 299   2                RomCode[j] = ReadOneChar() ; 
 300   2               }
 301   1      }
 302          
 303          /*******************************************************************/
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 6   

 304          /*                                                                 */
 305          /*DS18B20的CRC8校验程序                                            */
 306          /*                                                                 */
 307          /*******************************************************************/
 308          uchar CRC8() 
 309          { 
 310   1         uchar i,x; uchar crcbuff;
 311   1         
 312   1         crc=0;
 313   1         for(x = 0; x <8; x++)
 314   1         {
 315   2          crcbuff=RomCode[x];
 316   2          for(i = 0; i < 8; i++) 
 317   2           { 
 318   3            if(((crc ^ crcbuff)&0x01)==0) 
 319   3            crc >>= 1; 
 320   3             else { 
 321   4                    crc ^= 0x18;   //CRC=X8+X5+X4+1
 322   4                    crc >>= 1; 
 323   4                    crc |= 0x80; 
 324   4                  }         
 325   3            crcbuff >>= 1;       
 326   3               }
 327   2         }
 328   1           return crc;        
 329   1      }
 330          /*******************************************************************/
 331          /*                                                                 */
 332          /* 数据转换与显示                                                  */
 333          /*                                                                 */
 334          /*******************************************************************/
 335          
 336           Disp_RomCode()
 337          {
 338   1         uchar j;
 339   1         uchar H_num=0x40;       //LCD第二行初始位置
 340   1      
 341   1         for(j=0;j<8;j++)
 342   1         {
 343   2          Temp = RomCode[j];
 344   2      
 345   2          display[0]=((Temp&0xf0)>>4);
 346   2          if(display[0]>9)
 347   2           { display[0]=display[0]+0x37;}
 348   2          else{display[0]=display[0]+0x30;}
 349   2      
 350   2          lcd_pos(H_num);             
 351   2          lcd_wdat(display[0]);        //高位数显示 
 352   2      
 353   2          H_num++;
 354   2          display[1]=(Temp&0x0f);
 355   2          if(display[1]>9)
 356   2           {display[1]=display[1]+0x37;}
 357   2          else {display[1]=display[1]+0x30;}
 358   2      
 359   2          lcd_pos(H_num);             
 360   2          lcd_wdat(display[1]);        //低位数显示 
 361   2          H_num++;
 362   2         }
 363   1      }        
 364          
 365          /*******************************************************************/
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 7   

 366          /*                                                                 */
 367          /* 蜂鸣器响一声                                                    */
 368          /*                                                                 */
 369          /*******************************************************************/
 370          void beep()
 371            {
 372   1          unsigned char y;
 373   1          for (y=0;y<100;y++)
 374   1          {
 375   2            Delay(60);
 376   2            BEEP=!BEEP;                //BEEP取反
 377   2          } 
 378   1          BEEP=1;                      //关闭蜂鸣器
 379   1              Delay(40000);
 380   1        }
 381          
 382          /*******************************************************************/
 383          /*                                                                 */
 384          /* DS18B20 OK 显示菜单                                             */
 385          /*                                                                 */
 386          /*******************************************************************/
 387          void  Ok_Menu ()
 388          { 
 389   1          uchar  m;
 390   1          lcd_init();                //初始化LCD 
 391   1                  
 392   1          lcd_pos(0);                //设置显示位置为第一行的第1个字符
 393   1           m = 0;
 394   1          while(cdis1[m] != '\0')
 395   1           {                         //显示字符
 396   2             lcd_wdat(cdis1[m]);
 397   2             m++;
 398   2           }
 399   1      
 400   1          lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 401   1           m = 0;
 402   1          while(cdis2[m] != '\0')
 403   1           {
 404   2             lcd_wdat(cdis2[m]);      //显示字符
 405   2             m++;
 406   2           }
 407   1      }
 408          
 409          /*******************************************************************/
 410          /*                                                                 */
 411          /* DS18B20 ERROR 显示菜单                                          */
 412          /*                                                                 */
 413          /*******************************************************************/
 414          void  Error_Menu ()
 415          {
 416   1           uchar  m;
 417   1           lcd_init();                //初始化LCD 
 418   1              
 419   1               lcd_pos(0);                //设置显示位置为第一行的第1个字符
 420   1           m = 0;
 421   1           while(cdis3[m] != '\0')
 422   1           {                         //显示字符
 423   2             lcd_wdat(cdis3[m]);
 424   2             m++;
 425   2           }
 426   1      
 427   1           lcd_pos(0x40);             //设置显示位置为第二行第1个字符
C51 COMPILER V8.06   0                                                                     06/24/2012 20:09:25 PAGE 8   

 428   1           m = 0;
 429   1           while(cdis4[m] != '\0')
 430   1           {
 431   2             lcd_wdat(cdis4[m]);      //显示字符
 432   2             m++;
 433   2           }
 434   1      }
 435          
 436          /*******************************************************************/
 437          /*                                                                 */
 438          /* 主函数                                                          */
 439          /*                                                                 */
 440          /*******************************************************************/
 441          void main()
 442           {
 443   1           P0 = 0xff;
 444   1           P2 = 0xff;
 445   1      
 446   1         while(1)
 447   1        {
 448   2           Ok_Menu ();
 449   2           Read_RomCord();    //读取64位序列码
 450   2           CRC8();            //CRC效验
 451   2           if(crc==0)         //CRC效验正确
 452   2               {
 453   3                Disp_RomCode();       //显示64位序列码
 454   3                beep();
 455   3           }
 456   2           while(!presence)
 457   2               {
 458   3                Init_DS18B20();
 459   3                delay1(1000);
 460   3               }
 461   2      
 462   2           Error_Menu ();
 463   2              do
 464   2               {  
 465   3                 Init_DS18B20();
 466   3                 beep();
 467   3           }
 468   2              while(presence);
 469   2        }
 470   1      }
 471          
 472          /*******************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    641    ----
   CONSTANT SIZE    =     68    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
